---
title: "R Notebook"
output: html_notebook
---
```{r}
library(dplyr)
library(ggplot2)
library(readr)
library(stringr)
library(ROSE)
library(ranger)


training <- read_csv("C:/Users/fvoss/Google Drive/Uni_5_Semester/Studienarbeit/training.csv", 
    col_types = cols(RefId = col_number(), 
        VehYear = col_number(), VehicleAge = col_number(), 
        WheelTypeID = col_number(), VehOdo = col_number(), 
        MMRAcquisitionAuctionAveragePrice = col_number(), 
        MMRAcquisitionAuctionCleanPrice = col_number(), 
        MMRAcquisitionRetailAveragePrice = col_number(), 
        MMRAcquisitonRetailCleanPrice = col_number(), 
        MMRCurrentAuctionAveragePrice = col_number(), 
        MMRCurrentAuctionCleanPrice = col_number(), 
        MMRCurrentRetailAveragePrice = col_number(), 
        MMRCurrentRetailCleanPrice = col_number(), 
        BYRNO = col_number(), VNZIP1 = col_number(), 
        VehBCost = col_number(), IsOnlineSale = col_number(), 
        WarrantyCost = col_number()))
```
Data Understanding
Dieser Abschnitt dient dazu, die vorhandenen Daten zu verstehen und zu interpretieren.
Zunächst wird die Summary des Trainingdatensatzes betrachtet:

```{r}
summary(training)
```
Danach wird geprüft, ob die angegebenen Datentypen auch zu den Werten der Daten passen.
```{r}
head(training)
```

Die Spalten, die den Preis enthalten, sind falsch dargestellt und müssen in "double" umgewandelt werden. Daher wird zuerst geschaut, ob nicht konvertierbare Einträge vorhanden sind:
```{r}

filteredData <- training %>%
  filter(MMRAcquisitionAuctionAveragePrice != "NULL")%>%
  filter(MMRAcquisitionAuctionCleanPrice != "NULL")%>%
  filter(MMRAcquisitionRetailAveragePrice != "NULL")%>%
  filter(MMRAcquisitonRetailCleanPrice != "NULL")%>%
  filter(MMRCurrentAuctionAveragePrice != "NULL")%>%
  filter(MMRCurrentAuctionCleanPrice != "NULL")%>%
  filter(MMRCurrentRetailAveragePrice != "NULL")%>%
  filter(MMRCurrentRetailCleanPrice != "NULL")
  
```
Durch diese Filterung fallen 315 Datensätze weg, was im Verhältnis zu dem großen Datensatz kaum Auswirkungen hat.
Nun können wir die Spalten umwandeln.

```{r}
filteredData$MMRAcquisitionAuctionAveragePrice <- as.numeric(as.character(filteredData$MMRAcquisitionAuctionAveragePrice))
filteredData$MMRAcquisitionAuctionCleanPrice <- as.numeric(as.character(filteredData$MMRAcquisitionAuctionCleanPrice))
filteredData$MMRAcquisitionRetailAveragePrice <- as.numeric(as.character(filteredData$MMRAcquisitionRetailAveragePrice))
filteredData$MMRAcquisitonRetailCleanPrice <- as.numeric(as.character(filteredData$MMRAcquisitonRetailCleanPrice))
filteredData$MMRCurrentAuctionAveragePrice <- as.numeric(as.character(filteredData$MMRCurrentAuctionAveragePrice))
filteredData$MMRCurrentAuctionCleanPrice <- as.numeric(as.character(filteredData$MMRCurrentAuctionCleanPrice))
filteredData$MMRCurrentRetailAveragePrice <- as.numeric(as.character(filteredData$MMRCurrentRetailAveragePrice))
filteredData$MMRCurrentRetailCleanPrice <- as.numeric(as.character(filteredData$MMRCurrentRetailCleanPrice))


```

Nach Umwandlung erneut Summary aufrufen:

```{r}
summary(filteredData)
```
Das Attribut "WheelId" beinhaltet noch 3167 NA'S. 





Nach der Umwandlung sind die Zahlen nun richtig dargestellt.

Die numerischen Werte werden ausgewählt, um eine Korrelationsmatrix zu erstellen:

```{r}
matrixData <- filteredData %>%
  select(IsBadBuy, VehYear, VehicleAge, WheelTypeID, VehOdo, MMRAcquisitionAuctionAveragePrice, MMRAcquisitionAuctionCleanPrice, MMRAcquisitionRetailAveragePrice, MMRAcquisitonRetailCleanPrice, MMRCurrentAuctionAveragePrice, MMRCurrentAuctionCleanPrice, MMRCurrentRetailAveragePrice, MMRCurrentRetailCleanPrice, BYRNO, VNZIP1, VehBCost, WarrantyCost)


cor(matrixData, method ="pearson")
```


Beim Betrachten der Summary kommt folgende Vermutung: 
Datensatz im Hinblick auf das Attribut "IsBadBuy" nicht balanciert. Überprüfe mit Hilfe eines einfachen Plots:
```{r}
groupedByBad <- filteredData %>%
  select(1,2)
groupedByBad <- groupedByBad %>%
  count(IsBadBuy)

ggplot(data = groupedByBad, mapping=aes(x=IsBadBuy,y=n))+
  geom_bar(stat='identity')
head(groupedByBad)
```


Im Weiteren wird die Verteilung des Alters der Fahrzeuge betrachtet:

```{r}
groupedByAge <- filteredData %>%
  select(1,6)%>%
  count(VehicleAge)
ggplot(data = groupedByAge, mapping=aes(x=VehicleAge,y=n))+
  geom_bar(stat='identity')
```
Hierbei handelt es sich um eine nach links verlagerte Gleichverteilung. Interessanter wird hier der Anteil der Fahrzeuge sein, die als Fehlkauf markiert wurden:

```{r}
groupedByAgeAndIsBad <- filteredData %>%
  select(1,2,6)%>%
  group_by(IsBadBuy, VehicleAge)%>%
  count(VehicleAge)


ggplot(groupedByAgeAndIsBad, aes(fill=IsBadBuy, y=n, x=VehicleAge)) + 
    geom_bar(position="dodge", stat="identity")

```
Um diesen Anstieg der "Kicks" im Alter besser darzustellen, folgt ein Graph, der das Verhältnis darstellt:

```{r}
groupedByAgeAndIsBad <- groupedByAgeAndIsBad %>%
  group_by(VehicleAge)%>%
  mutate(n2 = sum(n))%>%
  group_by(VehicleAge, add = TRUE)%>%
  mutate(percentageBadBuy=round(100*n/n2,2))%>%
  filter(IsBadBuy == 1)

ggplot(groupedByAgeAndIsBad, aes(x = VehicleAge, y = percentageBadBuy))+
  geom_line()

```
Je älter ein Fahrzeug also ist, umso wahrscheinlicher ist, dass es ein Fehlkauf ist.

Weiter wird untersucht, ob die Laufleistung im Bezug auf das Fahrzeugalter eine ähnliche Entwicklung erfährt:

```{r}
groupedByOdo <- filteredData %>%
  select(1,2,15)

summary(groupedByOdo)
```
Teile den Datensatz in zwei Gruppen, um den Anteil der Fehlkäufe bei wenig Laufleistung mit denen höherer Laufleistung vergleichen zu können. Nehme hierfür die Hälfte des Datensatzes.

```{r}
groupedByOdoLow <- groupedByOdo[with(groupedByOdo, order(VehOdo)),][1:36334,] %>%
  group_by(IsBadBuy)%>%
  count(IsBadBuy)%>%
  mutate(split = "LowerOdo")

groupedByOdoHigh <- groupedByOdo[with(groupedByOdo, order(VehOdo)),][36335:72668,] %>%
  group_by(IsBadBuy)%>%
  count(IsBadBuy)%>%
  mutate(split = "UpperOdo")

combined <- bind_rows(groupedByOdoHigh, groupedByOdoLow)
head(combined)
ggplot(combined, aes(fill = IsBadBuy, y=n, x = split)) + 
  geom_bar(stat="identity")


```
Der Anteil der Fehlkäufe liegt bei höhrerem Kilometerstand nur leicht über dem der Fahrzeuge mit weniger Laufleistung.

Weiter wird der überprüft, ob gewisse Automarken einen höheren Anteil an Fehlkäufen haben als andere.

```{r}
groupedByMake <- filteredData %>%
  select(1,2,7)%>%
  group_by(IsBadBuy, Make)%>%
  count(Make)%>%
  group_by(Make)%>%
  mutate(n2 = sum(n))%>%
  group_by(Make, add = TRUE)%>%
  mutate(percentageBadBuy=round(100*n/n2,2))%>%
  filter(IsBadBuy == 1)

ggplot(groupedByMake, aes(x = Make, y = percentageBadBuy))+
  geom_bar(stat="identity")
```
Bei kurzen Blick auf die Ergebnisse sind ein paar Ausreißer festzustellen. Dies könnte an zu wenig Datensätzen bei einigen Herstellern liegen.



```{r}
groupedByMake <- filteredData %>%
  select(1,2,7)%>%
  group_by(IsBadBuy, Make)%>%
  count(Make)



summary(groupedByMake)
```
Problem bei obiger Darstellung ist, dass zum Beispiel der Hersteller Plymouth zwar einen hohen Anteil an schlechten Fahrzeugen hat, allerdings sind nur zwei Datensätze zu diesem Hersteller vorhanden, sodass diese Grafik nicht aussagekräftig genug ist.
Das spiegelt sich auch in der Summary des Datensatzes wieder, da eine sehr hohe Range vorhanden ist und der Datensatz stark linksverteilt ist.




Im Folgenden KAPITEL DATA PREPARATION
Als erstes fallen die ID's heraus
```{r}
filteredData <- filteredData %>%
  select(-RefId, -WheelTypeID, -BYRNO, -PRIMEUNIT, -AUCGUART, -VNZIP1)
```
Untersuche auf weitere fehlende Werte:
```{r}
sum(is.na(filteredData$IsBadBuy))
sum(is.na(filteredData$PurchDate))
sum(is.na(filteredData$Auction))
sum(is.na(filteredData$VehYear))
sum(is.na(filteredData$VehicleAge))
sum(is.na(filteredData$Make))
sum(is.na(filteredData$Model))
sum(is.na(filteredData$Trim))
sum(is.na(filteredData$SubModel))
sum(is.na(filteredData$Color))
sum(is.na(filteredData$Transmission))
sum(is.na(filteredData$WheelType))
sum(is.na(filteredData$VehOdo))
sum(is.na(filteredData$Nationality))
sum(is.na(filteredData$Size))
sum(is.na(filteredData$TopThreeAmericanName))
sum(is.na(filteredData$VNST))
sum(is.na(filteredData$VehBCost))
sum(is.na(filteredData$IsOnlineSale))
sum(is.na(filteredData$WarrantyCost))

```


Es fällt die Spalte TRIM auf, in der es fehlende Werte gibt. Da es sich hier um ein kategorisches Attribut handelt, kann kein Durchschnittswert eingefügt werden. Deshalb werden die Spalten mit den fehlenden Werten aus dem Datensatz entfernt.

```{r}
filteredData <- na.omit(filteredData)
```
In der ursprünglichen Datei gibt es sowhl leere Fehler, als auch Fehler mit dem String "NULL". Diese müssen gefiltert werden.
Überprüfe in welchen Attributen diese "NULL" Einträge vorhanden sind:

```{r}
(grep("NULL", filteredData))

```

```{r}
filteredData <- filteredData %>%
  filter(SubModel != "NULL")%>%
  filter(Color != "NULL")%>%
  filter(Transmission != "NULL")%>%
  filter(WheelType != "NULL")%>%
  filter(Nationality != "NULL")%>%
  filter(Size != "NULL")%>%
  filter(TopThreeAmericanName != "NULL")
```
Filter numerische Attribute. Nehme den Durchschnitt des gesamten Attributes und füge ihn dort ein, wo Werte = 0 sind.

```{r}
#MMRAcquisitionAuctionAveragePrice
is.na(filteredData$MMRAcquisitionAuctionAveragePrice) <- filteredData$MMRAcquisitionAuctionAveragePrice == 0
filteredData$MMRAcquisitionAuctionAveragePrice[is.na(filteredData$MMRAcquisitionAuctionAveragePrice)]<-mean(filteredData$MMRAcquisitionAuctionAveragePrice,na.rm=TRUE)

#MMRAcquisitionAuctionCleanPrice
is.na(filteredData$MMRAcquisitionAuctionCleanPrice) <- filteredData$MMRAcquisitionAuctionCleanPrice== 0
filteredData$MMRAcquisitionAuctionCleanPrice[is.na(filteredData$MMRAcquisitionAuctionCleanPrice)]<-mean(filteredData$MMRAcquisitionAuctionCleanPrice,na.rm=TRUE)

#MMRAcquisitionRetailAveragePrice
is.na(filteredData$MMRAcquisitionRetailAveragePrice) <- filteredData$MMRAcquisitionRetailAveragePrice== 0
filteredData$MMRAcquisitionRetailAveragePrice[is.na(filteredData$MMRAcquisitionRetailAveragePrice)]<-mean(filteredData$MMRAcquisitionRetailAveragePrice,na.rm=TRUE)

#MMRAcquisitonRetailCleanPrice
is.na(filteredData$MMRAcquisitonRetailCleanPrice) <- filteredData$MMRAcquisitonRetailCleanPrice== 0
filteredData$MMRAcquisitonRetailCleanPrice[is.na(filteredData$MMRAcquisitonRetailCleanPrice)]<-mean(filteredData$MMRAcquisitonRetailCleanPrice,na.rm=TRUE)

#MMRCurrentAuctionAveragePrice
is.na(filteredData$MMRCurrentAuctionAveragePrice) <- filteredData$MMRCurrentAuctionAveragePrice== 0
filteredData$MMRCurrentAuctionAveragePrice[is.na(filteredData$MMRCurrentAuctionAveragePrice)]<-mean(filteredData$MMRCurrentAuctionAveragePrice,na.rm=TRUE)

#MMRCurrentAuctionCleanPrice
is.na(filteredData$MMRCurrentAuctionCleanPrice) <- filteredData$MMRCurrentAuctionCleanPrice== 0
filteredData$MMRCurrentAuctionCleanPrice[is.na(filteredData$MMRCurrentAuctionCleanPrice)]<-mean(filteredData$MMRCurrentAuctionCleanPrice,na.rm=TRUE)

#MMRCurrentRetailAveragePrice
is.na(filteredData$MMRCurrentRetailAveragePrice) <- filteredData$MMRCurrentRetailAveragePrice== 0
filteredData$MMRCurrentRetailAveragePrice[is.na(filteredData$MMRCurrentRetailAveragePrice)]<-mean(filteredData$MMRCurrentRetailAveragePrice,na.rm=TRUE)

#MMRCurrentRetailCleanPrice
is.na(filteredData$MMRCurrentRetailCleanPrice) <- filteredData$MMRCurrentRetailCleanPrice== 0
filteredData$MMRCurrentRetailCleanPrice[is.na(filteredData$MMRCurrentRetailCleanPrice)]<-mean(filteredData$MMRCurrentRetailCleanPrice,na.rm=TRUE)

```

Im Attribut Submodel sind noch weitere Informationen, die als eigenes Attribut herausgestellt werden müssen.

Viele fangen mit "2D" oder "4D" an, was die Anzahl der Türen beschreibt. Dies muss in eine eigene Spalte.
```{r}

filteredData <- filteredData %>%
  mutate(Doors = str_extract(SubModel, "[0-9]+D"))

filteredData$SubModel <- gsub( "[0-9]+D", "", filteredData$SubModel)

```


Weiter enthält das Attribut "Model" noch Informationen über Zwei- bzw. Vierradantrieb, sowie über die Anzahl der Zylinder.
```{r}

filteredData <- filteredData %>%
  mutate(Cylinder = str_extract(Model, c("[0-9]+C","V+[0-9]")))

filteredData$Model <- gsub( "[0-9]+\\C", "", filteredData$Model)
filteredData$Model <- gsub( "V+[0-9]", "", filteredData$Model)

```

Filtere 3.7L mit Regex
```{r}

filteredData <- filteredData %>%
  mutate(Liter = str_extract(SubModel, "[0-9]+\\.[0-9]+L"))%>%
  mutate(Liter2 = str_extract(Model, "[0-9]+\\.[0-9]+L"))

filteredData$Liter <- ifelse(is.na(filteredData$Liter), filteredData$Liter2, filteredData$Liter)

filteredData <- filteredData %>%
  select(-Liter2)


filteredData$SubModel <- gsub( "[0-9]+\\.[0-9]+L", "", filteredData$SubModel)
filteredData$Model <- gsub( "[0-9]+\\.[0-9]+L", "", filteredData$Model)
```

Filtere FWD / 4WD / 2WD

```{r}
filteredData <- filteredData %>%
  mutate(WheelDrive = str_extract(Model, "([2-4]|F|A)+WD"))

filteredData$Model <- gsub( "([2-4]|F)+WD", "", filteredData$Model)

```


Entferne überflüssige Leerzeichen aus den manipulierten Zeilen
```{r}
filteredData$Model <- str_squish(filteredData$Model)

filteredData$SubModel <- str_squish(filteredData$SubModel)

```


Führe Up- / Downsampling durch

```{r}





filteredData <- filteredData %>%
  mutate(
    IsBadBuy = factor(IsBadBuy),
    Auction = factor(Auction),
    Make = factor(Make),
    Model = factor(Model),
    Trim = factor(Trim),
    SubModel = factor(SubModel),
    Color = factor(Color),
    Transmission = factor(Transmission),
    WheelType = factor(WheelType),
    Nationality = factor(Nationality),
    Size = factor(Size),
    TopThreeAmericanName = factor(TopThreeAmericanName),
    VNST = factor(VNST),
    IsOnlineSale = factor(IsOnlineSale),
    WheelDrive = factor(WheelDrive),
    Doors = factor(Doors),
    Liter = factor(Liter),
    Cylinder = factor(Cylinder)
  )

filteredDataSelected <- filteredData %>%
  select(-Cylinder, -WheelDrive, -Liter, -Doors)



table(filteredData$IsBadBuy)

summary(filteredData)


filteredDataBalanced <- ovun.sample(IsBadBuy ~ ., data = filteredDataSelected, method = "both", p = 0.5)$data

balanced <- table(filteredDataBalanced$IsBadBuy)

modelData <- filteredDataBalanced

```
PREPARE TEST DATA

```{r}
testData <- read_csv("C:/Users/fvoss/Google Drive/Uni_5_Semester/Studienarbeit/test.csv", 
    col_types = cols(RefId = col_number(), 
        VehYear = col_number(), VehicleAge = col_number(), 
        WheelTypeID = col_number(), VehOdo = col_number(), 
        MMRAcquisitionAuctionAveragePrice = col_number(), 
        MMRAcquisitionAuctionCleanPrice = col_number(), 
        MMRAcquisitionRetailAveragePrice = col_number(), 
        MMRAcquisitonRetailCleanPrice = col_number(), 
        MMRCurrentAuctionAveragePrice = col_number(), 
        MMRCurrentAuctionCleanPrice = col_number(), 
        MMRCurrentRetailAveragePrice = col_number(), 
        MMRCurrentRetailCleanPrice = col_number(), 
        BYRNO = col_number(), VNZIP1 = col_number(), 
        VehBCost = col_number(), IsOnlineSale = col_number(), 
        WarrantyCost = col_number()))


testData <- testData %>%
  filter(SubModel != "NULL")%>%
  filter(Color != "NULL")%>%
  filter(Transmission != "NULL")%>%
  filter(WheelType != "NULL")%>%
  filter(Nationality != "NULL")%>%
  filter(Size != "NULL")%>%
  filter(TopThreeAmericanName != "NULL")

testData$MMRAcquisitionAuctionAveragePrice <- as.numeric(as.character(testData$MMRAcquisitionAuctionAveragePrice))
testData$MMRAcquisitionAuctionCleanPrice <- as.numeric(as.character(testData$MMRAcquisitionAuctionCleanPrice))
testData$MMRAcquisitionRetailAveragePrice <- as.numeric(as.character(testData$MMRAcquisitionRetailAveragePrice))
testData$MMRAcquisitonRetailCleanPrice <- as.numeric(as.character(testData$MMRAcquisitonRetailCleanPrice))
testData$MMRCurrentAuctionAveragePrice <- as.numeric(as.character(testData$MMRCurrentAuctionAveragePrice))
testData$MMRCurrentAuctionCleanPrice <- as.numeric(as.character(testData$MMRCurrentAuctionCleanPrice))
testData$MMRCurrentRetailAveragePrice <- as.numeric(as.character(testData$MMRCurrentRetailAveragePrice))
testData$MMRCurrentRetailCleanPrice <- as.numeric(as.character(testData$MMRCurrentRetailCleanPrice))


testData <- testData %>%
  select(-RefId, -WheelTypeID, -BYRNO, -PRIMEUNIT, -AUCGUART, -VNZIP1)

na.omit(testData)


testData <- testData %>%
  filter(SubModel != "NULL")%>%
  filter(Color != "NULL")%>%
  filter(Transmission != "NULL")%>%
  filter(WheelType != "NULL")%>%
  filter(Nationality != "NULL")%>%
  filter(Size != "NULL")%>%
  filter(Trim != "NULL")%>%
  filter(TopThreeAmericanName != "NULL")%>%
  filter(MMRAcquisitionAuctionAveragePrice > 0)%>%
  filter(MMRAcquisitionAuctionCleanPrice > 0)%>%
  filter(MMRAcquisitionRetailAveragePrice > 0)%>%
  filter(MMRAcquisitonRetailCleanPrice > 0)%>%
  filter(MMRCurrentAuctionAveragePrice > 0)%>%
  filter(MMRCurrentAuctionCleanPrice > 0)%>%
  filter(MMRCurrentRetailAveragePrice > 0)%>%
  filter(MMRCurrentRetailCleanPrice > 0)


(grep("NULL", testData))
```



MODELLING



```{r}
rf_01 <- ranger(IsBadBuy ~ ., data = modelData, importance = "impurity", probability = TRUE, seed=42, num.trees = 1000)
print(rf_01)

```
Mache Vorhersagen

```{r}
predictions_validation_01 <- predict(rf_01, data = modelData, type = "response")$predictions[,2]
head(predictions_validation_01)

predictions_validation_binary_01 <- ifelse(predictions_validation_01>0.5,"1","0")

data_validation_w_preds_01 <- cbind(modelData, predictions_validation_01, predictions_validation_binary_01)

table(data_validation_w_preds_01$predictions_validation_binary_01)
library(Metrics)

1-ce(actual = data_validation_w_preds_01$IsBadBuy, predicted = data_validation_w_preds_01$predictions_validation_binary_01)
```


Pass an, sodass Trainingsdaten auch gesplittet werden und hier evaluiert werden können

library(Metrics)

1-ce(actual = data_validation_w_preds_01$IsBadBuy, predicted = data_validation_w_preds_01$predictions_validation_binary_01)

CrossTable(data_validation_w_preds_01$Decision, data_validation_w_preds_01$predictions_validation_binary_01, 
           prop.r=FALSE, prop.c=FALSE, prop.t=TRUE, prop.chisq=FALSE)
           
           















